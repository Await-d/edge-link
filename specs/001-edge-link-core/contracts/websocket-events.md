# WebSocket Events Specification

**Feature**: Edge-Link Core System
**Version**: 1.0.0
**Protocol**: WebSocket (WSS)
**Endpoint**: `wss://api.edgelink.example.com/ws/v1`

## Overview

Real-time bidirectional communication between control plane and management UI (admin) or clients (devices). Supports server-initiated push notifications and client-initiated actions.

**Connection Lifecycle**:
1. Client initiates WebSocket handshake with authentication (Bearer token for admin, device signature for clients)
2. Server sends `CONNECTED` event upon successful handshake
3. Server/client exchange messages with JSON framing
4. Heartbeat ping/pong every 30s to detect stale connections
5. Reconnection with exponential backoff (1s, 2s, 4s, 8s, max 60s) on disconnect

---

## Message Format

All messages follow this JSON structure:

```json
{
  "type": "EVENT_TYPE",
  "payload": { /* event-specific data */ },
  "timestamp": "2025-10-19T10:00:00Z",
  "correlation_id": "uuid-v4"  // Optional: for request-response pairing
}
```

---

## Server-to-Client Events

### CONNECTED

**Description**: Confirmation of successful WebSocket connection

**Payload**:
```json
{
  "connection_id": "conn-123e4567",
  "server_time": "2025-10-19T10:00:00Z"
}
```

---

### DEVICE_STATUS_CHANGE

**Description**: Device online/offline status changed

**Payload**:
```json
{
  "device_id": "123e4567-e89b-12d3-a456-426614174000",
  "online": true,
  "last_seen_at": "2025-10-19T10:00:00Z",
  "nat_type": "port_restricted_cone"
}
```

**Trigger**: Device heartbeat timeout (offline) or heartbeat received (online)

---

### TUNNEL_ESTABLISHED

**Description**: New WireGuard tunnel established between devices

**Payload**:
```json
{
  "session_id": "session-uuid",
  "device_a_id": "device-uuid-1",
  "device_b_id": "device-uuid-2",
  "connection_type": "p2p_direct",
  "started_at": "2025-10-19T10:00:00Z"
}
```

---

### TUNNEL_FAILED

**Description**: Tunnel establishment failed or existing tunnel dropped

**Payload**:
```json
{
  "device_a_id": "device-uuid-1",
  "device_b_id": "device-uuid-2",
  "failure_reason": "symmetric_nat_no_turn",
  "timestamp": "2025-10-19T10:00:00Z",
  "retry_scheduled": false
}
```

---

### ALERT_CREATED

**Description**: New alert generated by monitoring system

**Payload**:
```json
{
  "alert_id": "alert-uuid",
  "device_id": "device-uuid",
  "severity": "high",
  "type": "device_offline",
  "message": "Device 'John's Laptop' has been offline for 5 minutes",
  "metadata": {
    "last_seen_at": "2025-10-19T09:55:00Z"
  },
  "created_at": "2025-10-19T10:00:00Z"
}
```

---

### ALERT_UPDATED

**Description**: Alert status changed (acknowledged, resolved)

**Payload**:
```json
{
  "alert_id": "alert-uuid",
  "previous_status": "active",
  "new_status": "acknowledged",
  "acknowledged_by": "admin-user-uuid",
  "acknowledged_at": "2025-10-19T10:05:00Z"
}
```

---

### TOPOLOGY_UPDATE

**Description**: Network topology changed (device added/removed, network created)

**Payload**:
```json
{
  "virtual_network_id": "network-uuid",
  "change_type": "device_added",
  "affected_device_id": "device-uuid",
  "peer_updates": [
    {
      "device_id": "peer-device-uuid",
      "action": "add_peer"
    }
  ],
  "timestamp": "2025-10-19T10:00:00Z"
}
```

---

### KEY_ROTATION_SCHEDULED

**Description**: Device key rotation scheduled or in progress

**Payload**:
```json
{
  "device_id": "device-uuid",
  "current_key_expires_at": "2025-11-19T10:00:00Z",
  "rotation_window_start": "2025-11-15T00:00:00Z",
  "rotation_window_end": "2025-11-18T23:59:59Z",
  "status": "scheduled"
}
```

---

### METRICS_SUMMARY

**Description**: Periodic aggregated metrics push (every 5 minutes)

**Payload**:
```json
{
  "organization_id": "org-uuid",
  "period_start": "2025-10-19T10:00:00Z",
  "period_end": "2025-10-19T10:05:00Z",
  "total_devices": 247,
  "online_devices": 189,
  "p2p_connections": 152,
  "turn_relay_connections": 37,
  "total_bandwidth_mb": 1847.5,
  "avg_latency_ms": 42
}
```

---

## Client-to-Server Events

### SUBSCRIBE

**Description**: Subscribe to specific event types or device channels

**Payload**:
```json
{
  "event_types": ["DEVICE_STATUS_CHANGE", "ALERT_CREATED"],
  "device_ids": ["device-uuid-1", "device-uuid-2"],
  "virtual_network_ids": ["network-uuid"]
}
```

**Response**: Server sends `SUBSCRIPTION_CONFIRMED` event

---

### UNSUBSCRIBE

**Description**: Unsubscribe from event types or channels

**Payload**:
```json
{
  "event_types": ["METRICS_SUMMARY"],
  "device_ids": ["device-uuid-1"]
}
```

---

### TRIGGER_DIAGNOSTIC

**Description**: Admin initiates diagnostic bundle collection from device

**Payload**:
```json
{
  "device_id": "device-uuid",
  "include_logs": true,
  "include_wireguard_stats": true,
  "include_network_trace": false,
  "duration_seconds": 60
}
```

**Response**: Server sends `DIAGNOSTIC_STARTED` event

---

### REVOKE_DEVICE

**Description**: Admin initiates device revocation (alternative to REST API)

**Payload**:
```json
{
  "device_id": "device-uuid",
  "reason": "security_breach"
}
```

**Response**: Server sends `DEVICE_REVOKED` event

---

### ACKNOWLEDGE_ALERT

**Description**: Admin acknowledges alert (alternative to REST API)

**Payload**:
```json
{
  "alert_id": "alert-uuid"
}
```

**Response**: Server sends `ALERT_UPDATED` event

---

### PING

**Description**: Client heartbeat ping (every 30s)

**Payload**: `{}` (empty object)

**Response**: Server responds with `PONG` event

---

## Error Events

### ERROR

**Description**: Server-side error processing client request

**Payload**:
```json
{
  "error_code": "INVALID_SUBSCRIPTION",
  "message": "Device ID 'invalid-uuid' not found or access denied",
  "correlation_id": "original-request-correlation-id"
}
```

---

## Connection Requirements

**Authentication**:
- Admin clients: Bearer token in `Authorization` header during WebSocket handshake
- Device clients: Ed25519 signature in `X-Device-Signature` header

**Heartbeat**:
- Client must send `PING` every 30s
- Server responds with `PONG` within 5s
- Missing 3 consecutive pings triggers connection termination

**Reconnection**:
- Client implements exponential backoff: 1s, 2s, 4s, 8s, max 60s
- Jitter (Â±20%) to avoid thundering herd
- Server maintains subscription state for 5 minutes after disconnect to support seamless reconnection

---

## Security Considerations

1. **Authentication**: All connections authenticated via Bearer token (admin) or device signature
2. **Authorization**: Clients can only subscribe to events for their organization/devices (RBAC enforced)
3. **Rate Limiting**: Max 100 messages per second per connection (prevents abuse)
4. **Payload Validation**: All client-to-server messages validated against schema
5. **Connection Limits**: Max 10,000 concurrent WebSocket connections per control plane instance

---

## Example Flows

### Flow 1: Admin Monitors Device Status

1. Admin opens management UI, establishes WebSocket connection with Bearer token
2. Client sends `SUBSCRIBE` with `event_types: ["DEVICE_STATUS_CHANGE"]`
3. Server sends `SUBSCRIPTION_CONFIRMED`
4. When device goes offline, server pushes `DEVICE_STATUS_CHANGE` event to admin
5. Admin clicks "View Details", UI navigates to device page (no WebSocket action needed)

### Flow 2: Admin Revokes Compromised Device

1. Admin clicks "Revoke Device" button in UI
2. Client sends `REVOKE_DEVICE` event via WebSocket
3. Server processes revocation, sends `DEVICE_REVOKED` event to all subscribed admins
4. Server pushes `TUNNEL_FAILED` events for all active sessions involving revoked device
5. Revoked device's next heartbeat receives 401 Unauthorized, prompts re-registration

### Flow 3: Real-Time Topology Update

1. New device registers via REST API `/device/register`
2. Server allocates virtual IP, updates peer configurations
3. Server pushes `TOPOLOGY_UPDATE` event to subscribed admins
4. Server pushes `DEVICE_STATUS_CHANGE` (online=true) when device sends first heartbeat
5. UI updates topology graph in real-time

---

## Implementation Notes

- **Library**: Use gorilla/websocket (Go backend), native WebSocket API (JavaScript frontend)
- **Message Framing**: JSON with `\n` delimiter for easy streaming parsing
- **Broadcast**: Use Redis Pub/Sub for multi-instance WebSocket server coordination (message broadcast across pods)
- **Metrics**: Track WebSocket connections, message rates, subscription counts via Prometheus
